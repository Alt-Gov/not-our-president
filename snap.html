<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SNAP Households Across the US</title>
  <meta name="description" content="Donald Trump and his cronies don't care about millions of Americans who will starve without SNAP." />
  <link rel="stylesheet" href="src/assets/css/styles.min.css" />
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

  <!-- Chart.js for the state trend panel 
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script> -->

  <style>
    #app { display: grid; grid-template-columns: 1fr 380px; height: 100%; }
    #map { position: relative; }
    #map, #sidebar { height: 100%; }
    #sidebar { border-left: 1px solid #e5e7eb; padding: 16px; overflow: auto; }
    header { padding: 12px 16px; border-bottom: 1px solid #e5e7eb; display:flex; align-items:center; gap:12px; }
    header h1 { font-size: 16px; margin: 0; }
    .token { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; padding: 2px 6px; background:#f3f4f6; border:1px solid #e5e7eb; border-radius: 6px; }
    .legend { position: absolute; bottom: 12px; left: 12px; background: white; padding: 10px 12px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,.08); border: 1px solid #e5e7eb; font-size: 12px; }
    .legend h3 { margin: 0 0 8px; font-size: 12px; font-weight: 600; }
    .swatches { display: grid; grid-template-columns: 18px auto; gap: 6px 10px; align-items: center; }
    .swatch { width: 18px; height: 12px; border-radius: 2px; border:1px solid rgba(0,0,0,.1) }
    .popup { font-size: 12px; }
    .footer { font-size: 12px; color: #6b7280; padding: 8px 0; }
    .pill { display:inline-block; background:#f3f4f6; padding:2px 6px; border-radius:999px; font-size:11px; border:1px solid #e5e7eb; }
    .btn { cursor:pointer; padding:8px 10px; border:1px solid #e5e7eb; border-radius:8px; background:white; font-size:12px; }
    .btn:hover { background:#f9fafb; }
    .muted { color:#6b7280; }
  </style>
</head>
<body>
  <header>
    <h1>SNAP Households — US Choropleth (Albers)</h1>
    <span class="muted">Click any state to zoom and see a 5‑year trend.</span>
  </header>
  <div id="app">
    <div id="map"></div>
    <aside id="sidebar">
      <h2 id="panel-title">Select a state</h2>
      <p class="muted">Showing average monthly <strong>households</strong> receiving SNAP benefits. Data: FY2020–FY2025.</p>
      <canvas id="trend" width="360" height="240" aria-label="State trend chart"></canvas>
      <div class="footer">Source: USDA SNAP participation (provided). Projection: <span class="pill">Albers USA</span></div>
    </aside>
  </div>

  <script>
    // 1) Provide your Mapbox token
    mapboxgl.accessToken = "YOUR_MAPBOX_ACCESS_TOKEN"; // ← replace me

    // 2) Paths to data files
    const SNAP_URL = "snap_households_2016_2025.json"; // place this file next to this HTML
    const STATES_GEOJSON_URL = "https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json";

    // 3) Basic color palette for choropleth (light → dark)
    const COLORS = ["#eef2ff", "#c7d2fe", "#a5b4fc", "#818cf8", "#6366f1", "#4f46e5"]; // 6-class

    // Globals
    let map, snapByStateYear, latestYear, breaks, colorByState = new Map();
    let trendChart;

    // Utility: compute quantile breaks
    function quantile(values, q) {
      const sorted = [...values].sort((a,b)=>a-b);
      const pos = (sorted.length - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base + 1] !== undefined) {
        return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
      } else {
        return sorted[base];
      }
    }

    function computeBreaks(vals) {
      // 5 thresholds (for 6 colors)
      return [0.2, 0.4, 0.6, 0.8, 0.95].map(q => Math.round(quantile(vals, q)));
    }

    function colorFor(value) {
      if (value == null || isNaN(value)) return "#ddd";
      const [b1,b2,b3,b4,b5] = breaks;
      if (value <= b1) return COLORS[0];
      if (value <= b2) return COLORS[1];
      if (value <= b3) return COLORS[2];
      if (value <= b4) return COLORS[3];
      if (value <= b5) return COLORS[4];
      return COLORS[5];
    }

    function updateLegend() {
      const legend = document.querySelector('.legend .swatches');
      legend.innerHTML = '';
      const labels = [
        `≤ ${breaks[0].toLocaleString()}`,
        `${(breaks[0]+1).toLocaleString()} – ${breaks[1].toLocaleString()}`,
        `${(breaks[1]+1).toLocaleString()} – ${breaks[2].toLocaleString()}`,
        `${(breaks[2]+1).toLocaleString()} – ${breaks[3].toLocaleString()}`,
        `${(breaks[3]+1).toLocaleString()} – ${breaks[4].toLocaleString()}`,
        `> ${breaks[4].toLocaleString()}`
      ];
      const colors = COLORS;
      labels.forEach((lab, i) => {
        const sw = document.createElement('div');
        sw.className = 'swatch';
        sw.style.background = colors[i];
        const txt = document.createElement('div');
        txt.textContent = lab;
        legend.appendChild(sw); legend.appendChild(txt);
      });
      document.getElementById('panel-title').textContent = `Most recent year: FY${latestYear}`;
    }

    function buildColorExpression(featureCollection) {
      const matchExpr = ['match', ['get', 'name']];
      featureCollection.features.forEach(f => {
        const name = f.properties.name; // state name
        const v = colorByState.get(name);
        matchExpr.push(name, v || '#ddd');
      });
      matchExpr.push('#ddd');
      return matchExpr;
    }

    function prepareTrendChart(stateName) {
      const ctx = document.getElementById('trend');
      const series = (snapByStateYear.get(stateName) || []).sort((a,b)=>a.year-b.year);
      const labels = series.map(d => `FY${d.year}`);
      const values = series.map(d => d.households);

      if (trendChart) trendChart.destroy();
      trendChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [{ label: `${stateName} — SNAP households`, data: values, tension: 0.2 }]
        },
        options: {
          responsive: true,
          plugins: { legend: { display: false } },
          scales: {
            y: { beginAtZero: true, ticks: { callback: v => v.toLocaleString() } }
          }
        }
      });
    }

    async function init() {
      // Load data
      const [snap, states] = await Promise.all([
        fetch(SNAP_URL).then(r => r.json()),
        fetch(STATES_GEOJSON_URL).then(r => r.json())
      ]);

      // Reshape SNAP: Map state -> [{year, households}]
      snapByStateYear = new Map();
      latestYear = Math.max(...snap.map(d => d.year));
      snap.forEach(d => {
        if (!snapByStateYear.has(d.state)) snapByStateYear.set(d.state, []);
        snapByStateYear.get(d.state).push({ year: d.year, households: +d.households });
      });

      // Compute latest-year value by state and color mapping
      const latestValues = [];
      states.features.forEach(f => {
        const name = f.properties.name;
        const arr = snapByStateYear.get(name) || [];
        const latest = arr.find(x => x.year === latestYear);
        const val = latest ? latest.households : null;
        colorByState.set(name, colorFor(val)); // temporary, breaks not yet computed
        if (val != null) latestValues.push(val);
      });

      // Now compute quantile breaks from all latest values, then update colorByState
      breaks = computeBreaks(latestValues);
      states.features.forEach(f => {
        const name = f.properties.name;
        const arr = snapByStateYear.get(name) || [];
        const latest = arr.find(x => x.year === latestYear);
        const val = latest ? latest.households : null;
        colorByState.set(name, colorFor(val));
      });

      // Render legend shell
      const legendDiv = document.createElement('div');
      legendDiv.className = 'legend';
      legendDiv.innerHTML = `<h3>SNAP households (avg / month)</h3><div class="swatches"></div>`;
      document.getElementById('map').appendChild(legendDiv);
      updateLegend();

      // Initialize map
      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/light-v11',
        projection: 'albers',
        center: [-98, 38],
        zoom: 2.8,
        minZoom: 2.3
      });

      map.addControl(new mapboxgl.NavigationControl({showCompass:false}), 'top-right');
      map.addControl(new mapboxgl.ScaleControl({ maxWidth: 120, unit: 'imperial' }));

      map.on('load', () => {
        map.addSource('states', { type: 'geojson', data: states });

        // Fill layer with categorical color expression by state name
        map.addLayer({
          id: 'states-fill',
          type: 'fill',
          source: 'states',
          paint: {
            'fill-color': buildColorExpression(states),
            'fill-opacity': 0.9
          }
        });

        map.addLayer({
          id: 'states-outline',
          type: 'line',
          source: 'states',
          paint: { 'line-color': '#ffffff', 'line-width': 0.8 }
        });

        const popup = new mapboxgl.Popup({ closeButton: false, closeOnClick: false });

        // Hover tooltip
        map.on('mousemove', 'states-fill', (e) => {
          map.getCanvas().style.cursor = 'pointer';
          const f = e.features[0];
          const name = f.properties.name;
          const latest = (snapByStateYear.get(name) || []).find(x => x.year === latestYear);
          const households = latest ? latest.households : null;
          popup.setLngLat(e.lngLat).setHTML(
            `<div class="popup"><strong>${name}</strong><br/>FY${latestYear}: ${households ? households.toLocaleString() : 'n/a'} households</div>`
          ).addTo(map);
        });
        map.on('mouseleave', 'states-fill', () => { map.getCanvas().style.cursor = ''; popup.remove(); });

        // Click: zoom and update side panel trend
        map.on('click', 'states-fill', (e) => {
          const f = e.features[0];
          const name = f.properties.name;
          const bbox = turf.bbox(f);
          map.fitBounds(bbox, { padding: 40, duration: 600 });
          document.getElementById('panel-title').textContent = `${name}`;
          prepareTrendChart(name);
        });
      });
    }

    // Turf.js (tiny build for bbox) — inline minimal bbox helper if Turf not available
    // We'll add a simple bbox function here to avoid another script dependency
    const turf = {
      bbox: function(feature) {
        const coords = [];
        (function walk(g) {
          if (g.type === 'Feature') return walk(g.geometry);
          if (g.type === 'GeometryCollection') return g.geometries.forEach(walk);
          if (g.type === 'Polygon' || g.type === 'MultiPolygon') {
            const polys = g.type === 'Polygon' ? [g.coordinates] : g.coordinates;
            polys.forEach(poly => poly.forEach(ring => ring.forEach(c => coords.push(c))));
          }
        })(feature);
        let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
        coords.forEach(c => { minX=Math.min(minX,c[0]); minY=Math.min(minY,c[1]); maxX=Math.max(maxX,c[0]); maxY=Math.max(maxY,c[1]); });
        return [[minX, minY], [maxX, maxY]];
      }
    };

    init();
  </script>
</body>
</html>
